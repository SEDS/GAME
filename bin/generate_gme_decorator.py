#!/usr/bin/env python
# $Id$

import getopt
import sys
import string
import uuid
import os
import re
import argparse

#
# generate_mwc_file
#
def generate_mwc_file (name, pathname):
    name_mwc = name + ".mwc"

    #Creating string template for .mwc file
    temp_mwc = string.Template ("""

workspace (${name}) {
  cmdline += -include $$GAME_ROOT/MPC/config
             
  ${name}.mpc
}""")

    replace_mwc = {'name' : name}

    #Creating a file object in write mode.
    file = open (pathname + name_mwc, "w")
    file.write (temp_mwc.substitute (replace_mwc))
    file.close ()

#
# generate_mpc_file
#
def generate_mpc_file (name, pathname, project, guid):
    name_mpc = name + ".mpc"

    #Creating string template for .mpc file
    temp_mpc = string.Template ("""// $$Id$$

project (${name}) : game_graphics, game_mga_decorator, game_lib {
  sharedname = $name

  pch_header = StdAfx.h
  pch_source = StdAfx.cpp

  Source_Files {
    ${name}_Impl.cpp
    ${name}_Module.cpp
    ${name}.idl
  }

  Resource_Files {

  }

  Header_Files {

  }
  
  specific (wix) {
    gme_decorator   = 1
    gme_progid      = ${project}.Decorator.${name}
    gme_uuid        = ${guid}
  }
}""")

    replace_mpc = {'name' : name,
                   'guid' : guid,
                   'project' : project}

    #Creating a file object in write mode.
    file = open (pathname + name_mpc, "w")
    file.write (temp_mpc.substitute (replace_mpc))
    file.close ()

#
# generate_stdafx_hfile
#
def generate_stdafx_hfile (name, pathname):
    name_stdafx_h = "StdAfx.h"

    #Creating string template for StdAfx.h file
    temp_stdafx_h = string.Template ("""// -*- C++ -**

#ifndef _STDAFX_H_
#define _STDAFX_H_

#if _MSC_VER > 1000
#pragma once
#endif // _MSC_VER > 1000

#define STRICT
#ifndef _WIN32_WINNT
  #if _MSC_VER > 1400
    #define _WIN32_WINNT 0x0500
  #else
    #define _WIN32_WINNT 0x0400
  #endif
#endif

#define _ATL_APARTMENT_THREADED

#include <afxwin.h>
#include <afxdisp.h>
#include <afxdlgs.h>
#include <afxcmn.h>
#include <afxcoll.h>
#include <afxtempl.h>

#include <atlbase.h>
#include <atlcom.h>
#include <Gdiplus.h>

#include "${name}.h"
#include "game/mga/MgaUtil.h"

#endif""")

    replace_stdafx_h = {'name' : name}

    #Creating a file object in write mode.
    file = open (pathname + name_stdafx_h, "w")
    file.write (temp_stdafx_h.substitute (replace_stdafx_h))
    file.close ()

#
# generate_stdafx_cppfile
#
def generate_stdafx_cppfile (pathname):
    name_stdafx_cpp = "StdAfx.cpp"

    #Creating file contents of StdAfx.cpp file
    temp_stdafx_cpp = ("""// $Id$

#include "StdAfx.h"

#ifdef _ATL_STATIC_REGISTRY

#include <statreg.h>

#if _ATL_VER < 0x0700
#include <statreg.cpp>
#endif // _ATL_VER < 0x0700

#endif // _ATL_STATIC_REGISTRY

#if _ATL_VER < 0x0700

#include <atlimpl.cpp>

#endif
""")

    #Creating a file object in write mode.
    file = open (pathname + name_stdafx_cpp, "w")
    file.write (temp_stdafx_cpp)
    file.close ()

#
# generate_idl_file
#
def generate_idl_file (name, pathname, comp_guid, lib_guid):
    name_idl = name + ".idl"

    #Creating string template for .idl file
    temp_idl = string.Template ("""// -*- IDL -*-

//=============================================================================
/**
 * @file      ${name}.idl
 *
 * This file was automatically generated by:
 *
 *   generate_gme_decorator.py
 */
//=============================================================================

#ifndef _${uname}_IDL_
#define _${uname}_IDL_

#include <Gme.idl>
#include <Core.idl>

[
  uuid (${lib_guid}),
  version (1.0),
]
library ${name}
{
  importlib ("stdole32.tlb");
  importlib ("stdole2.tlb");

  [
    uuid (${com_guid}),
    version (1.0)
  ]
  coclass ${name}
  {
    [default] interface IMgaElementDecorator;
    interface IGMEVersionInfo;
  };
};

#endif  // !defined _${uname}_IDL_
""")

    replace_idl = {'name' : name,
                   'uname' : name.upper (),
                   'lib_guid' : lib_guid,
                   'com_guid' : comp_guid }

    #Creating a file object in write mode.
    file = open (pathname + name_idl, "w")
    file.write (temp_idl.substitute (replace_idl))
    file.close ()   
    
#
# generate_impl_h_file
#
def generate_impl_h_file (name, pathname):
    name_impl_h = name + "_Impl.h"

    #Creating string template for .h file
    temp_impl_h = string.Template ("""// -*- C++ -*-

//=============================================================================
/**
 * @file       ${name}_Impl.h
 */
//=============================================================================

#ifndef _${uname}_IMPL_H_
#define _${uname}_IMPL_H_

#include "game/mga/decorator/Decorator_Impl.h"

class ${name}_Impl :
  public GAME::Mga::Decorator_Impl
{
public:
  /// Default constructor.
  ${name}_Impl (void);

  /// Destructor.
  virtual ~${name}_Impl (void);

  // Initialize decorator for Part Browser window.
  virtual int initialize (const GAME::Mga::Project & proj,
                          const GAME::Mga::Meta::Part_in part,
                          IMgaCommonDecoratorEvents * eventSink,
                          ULONGLONG parentWnd);

  // Initialize decorator for Model View window.
  virtual int initialize (const GAME::Mga::Project & proj,
                          const GAME::Mga::Meta::Part_in part,
                          const GAME::Mga::FCO_in fco,
                          IMgaCommonDecoratorEvents * eventSink,
                          ULONGLONG parentWnd);
};

#endif  // !defined _${uname}_IMPL_H_
""")

    replace_impl_h = {'name' : name,
                      'uname' : name.upper ()}

    #Creating a file object in write mode.
    file = open (pathname + name_impl_h, "w")
    file.write (temp_impl_h.substitute (replace_impl_h))
    file.close ()

#
# generate_module_cpp_file
#
def generate_module_cpp_file (name, pathname, lib_guid):
    name_module_cpp = name + "_Module.cpp"

    #Creating string template for _Module.cpp file
    temp_module_cpp = string.Template ("""// $$Id$$

#include "StdAfx.h"
#include "game/mga/decorator/Decorator_Module.h"
#include "${name}_i.c"

DECLARE_DECORATOR_MODULE (LIBID_${name}, 101, "{${lib_guid}}");

""")

    replace_module_cpp = {'name' : name,
                          'lib_guid' : lib_guid }

    #Creating a file object in write mode.
    file = open (pathname + name_module_cpp, "w")
    file.write (temp_module_cpp.substitute (replace_module_cpp))
    file.close ()
    
#
# generate_impl_cpp_file
#
def generate_impl_cpp_file (name, pathname, project):
    name_impl_cpp = name + "_Impl.cpp"

    #Creating string template for .cpp file
    temp_impl_cpp = string.Template ("""// $$Id$$

#include "StdAfx.h"

#include "${name}_Impl.h"
#include "${name}.h"
#include "game/mga/decorator/Decorator_T.h"

// other useful includes
#include "game/mga/MetaFCO.h"
#include "game/mga/graphics/Image_Resolver.h"
#include "game/mga/utils/Registrar.h"

DECLARE_DECORATOR (${name}, ${name}_Impl);

//
// ${name}_Impl
//
${name}_Impl::${name}_Impl (void)
{

}

//
// ~${name}_Impl
//
${name}_Impl::~${name}_Impl (void)
{

}


//
// initialize
//
int ${name}_Impl::
initialize (const GAME::Mga::Project & proj,
            const GAME::Mga::Meta::Part_in part,
            IMgaCommonDecoratorEvents * eventSink,
            ULONGLONG parentWnd)
{
  return 0;
}

//
// initialize
//
int ${name}_Impl::
initialize (const GAME::Mga::Project & proj,
            const GAME::Mga::Meta::Part_in part,
            const GAME::Mga::FCO_in fco,
            IMgaCommonDecoratorEvents * eventSink,
            ULONGLONG parentWnd)
{
  return 0;
}

""")

    replace_impl_cpp = {'name' : name}

    #Creating a file object in write mode.
    file = open (pathname + name_impl_cpp, "w")
    file.write (temp_impl_cpp.substitute (replace_impl_cpp))
    file.close ()

#
# validity_check
#
def validity_check (guid):
    if re.match ('^(\{){0,1}[0-9a-fA-F]{8}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{4}\-[0-9a-fA-F]{12}(\}){0,1}$', guid):
        return True
    
    print ('*** error:', guid, 'is invalid')
    
#
# generate_reg_file
#
def generate_reg_file (name, pathname, guid, project):
    name_reg = name + '.reg'

    #Creating string template for *.reg file
    temp_reg = string.Template ("""REGEDIT4

[HKEY_CURRENT_USER\Software\Classes]

[HKEY_CURRENT_USER\Software\Classes\CLSID]

[HKEY_CURRENT_USER\Software\Classes\CLSID\{${guid}}]
@="${project}.Decorator.${name}"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{${guid}}\ProgID]
@="${project}.Decorator.${name}"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{${guid}}\InProcServer32]
@="${name}.dll"

[HKEY_CURRENT_USER\Software\Classes\${project}.Decorator.${name}]
@="${project}.Decorator.${name}"

[HKEY_CURRENT_USER\Software\Classes\${project}.Decorator.${name}\CLSID]
@="{${guid}}"

""")

    replace_reg = {'name' : name,
                   'guid' : guid,
                   'project' : project}

    #Creating a file object in write mode.
    file = open (pathname + name_reg, "w")
    file.write (temp_reg.substitute (replace_reg))
    file.close ()

#
# generate_dreg_file
#
def generate_dreg_file (name, pathname, guid, project):
    name_dreg = name + 'd.reg'

    #Creating string template for *d.reg file
    temp_dreg = string.Template ("""REGEDIT4

[HKEY_CURRENT_USER\Software\Classes]

[HKEY_CURRENT_USER\Software\Classes\CLSID]

[HKEY_CURRENT_USER\Software\Classes\CLSID\{${guid}}]
@="${project}.Decorator.${name}"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{${guid}}\ProgID]
@="${project}.Decorator.${name}"

[HKEY_CURRENT_USER\Software\Classes\CLSID\{${guid}}\InProcServer32]
@="${name}d.dll"

[HKEY_CURRENT_USER\Software\Classes\${project}.Decorator.${name}]
@="${project}.Decorator.${name}"

[HKEY_CURRENT_USER\Software\Classes\${project}.Decorator.${name}\CLSID]
@="{${guid}}"


""")

    replace_reg = {'name' : name,
                   'guid' : guid,
                   'project' : project}

    #Creating a file object in write mode.
    file = open (pathname + name_dreg, "w")
    file.write (temp_dreg.substitute (replace_reg))
    file.close ()

#
# main
#    
def main (*argv):
    #Initializing the variable values
    comp_guid = uuid.uuid4 ()
    lib_guid = uuid.uuid4 ()
    pathname = os.getcwd () + os.sep
    name = 'Default'
    has_icon = False
    name = None
    project = 'GAME'

    #setting options and corresponding argument values
    parser = argparse.ArgumentParser ()
    parser.add_argument ('--name', type=str, required=True, help='Name of the decorator')
    parser.add_argument ('--project', type=str, help='Name of the project, defaults to GAME')
    parser.add_argument ('-o', '--directory', type=str, help='Output directory')

    args = parser.parse_args (sys.argv[1:])

    name = args.name

    if args.project:
        project = args.project

    if args.directory:
        pathname = os.path.join (os.getcwd (), args.directory + os.sep)
        if not os.path.isdir (pathname):
            os.makedirs (pathname)
                        
    #Calling respective function for creating .mwc file
    generate_mwc_file (name, pathname)

    #Calling respective function for creating .mpc file
    generate_mpc_file (name, pathname, project, comp_guid)

    #Calling respective function for creating .idl file
    generate_idl_file (name, pathname, comp_guid, lib_guid)

    #Calling respective function for creating stdafx.h file
    generate_stdafx_hfile (name, pathname)

    #Calling respective function for creating stdafx.cpp file
    generate_stdafx_cppfile (pathname)

    #Calling respective function for creating _Module.cpp file
    generate_module_cpp_file (name, pathname, lib_guid)

    #Calling respective function for creating *d.reg file
    generate_dreg_file (name, pathname, comp_guid, project)

    #Calling respective function for creating *.reg file
    generate_reg_file (name, pathname, comp_guid, project)

    #Calling respective function for creating _Impl.h file
    generate_impl_h_file (name, pathname)

    #Calling respective function for creating _Impl.cpp file
    generate_impl_cpp_file (name, pathname, project)

#
# __name__
#
if __name__ == "__main__":
    SystemExit (main ())
        
    



        
        
    
    
